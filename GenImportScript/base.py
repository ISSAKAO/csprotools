#!/usr/bin/python
# -*- coding: utf-8 -*-

# Code generated by META
# Created: Thu August 16 2012 4:59:9 pm
# by: CSProToPythonScript 1.0
# WARNING! All changes made in this file might be lost when running CSProToPythonScript!

#Importing required libraries
import sqlite3 as lite #SQLite library
import getopt #Library for processing command line argument
import sys #System library
import MySQLdb #MySQL library from http://mysql-python.sourceforge.net/ . Install it with "pip install MySQL-python"
import os #Library of OS operations

# This process generates an insert for each table.
# Receives:
# cntLite = Connection to the SQLite database
# cntMy = Connection to the MySQL database
# table = The table to be processed
# logFile = The log file to write any error  
def processTable(cntLite,  cntMy,  table,  logFile):
    cntLite.row_factory = lite.Row #Creates a dictionary to use field names
    liteCur = cntLite.cursor() #Cursor to SQLite database
    liteCur.execute("SELECT rowId,* FROM " +  table + ' WHERE uploaded = 0') #Select all table from the table
    rows = liteCur.fetchall() #Retrieve the records from SQLite
    rowID = 0 #RowID stores the current processing row in the table
    sql = '' #sql is a string to store the Insert SQL command 
    myCur = cntMy.cursor() #Cursor to the MySQL database

    #From here there is an if statement for each imported table
    
    if table.upper() == 'GENINFO':
         for row in rows: #Pass through each row of GENINFO
            rowID = row["rowId"] #Gets the current row
            #Constructs an insert SQL
            sql = 'INSERT INTO mainsurveyinfo (HH_ID,date,day,month,year,hheadname,gender,resp1name,resp1gen,resp2name,resp2gen,country,province,state,division,location,sublocation,village,latcard,latdeg,latmin,longcard,longdeg,longmin,elevation,prodsys,enumname,supname,language,rankingnotes'
            sql = sql + ') VALUES ('
            sql = sql + "'" + correctString(row["HH_ID"]) + "',"
            sql = sql + "'" + correctString(row["date"]) + "',"
            sql = sql + "'',"
            sql = sql + "'',"
            sql = sql + "'',"
            sql = sql + "'" + correctString(row["hheadname"]) + "',"
            sql = sql + "'" + correctString(row["gender"]) + "',"
            sql = sql + "'" + correctString(row["resp1name"]) + "',"
            sql = sql + "'" + correctString(row["resp1gen"]) + "',"
            sql = sql + "'" + correctString(row["resp2name"]) + "',"
            sql = sql + "'" + getEmpty(correctString(row["resp2gen"])) + "',"
            sql = sql + "'" + correctString(row["country"]) + "',"
            sql = sql + "'" + correctString(row["province"]) + "',"
            sql = sql + "'" + correctString(row["state"]) + "',"
            sql = sql + "'" + correctString(row["division"]) + "',"
            sql = sql + "'" + correctString(row["location"]) + "',"
            sql = sql + "'" + correctString(row["sublocation"]) + "',"
            sql = sql + "'" + correctString(row["village"]) + "',"
            sql = sql + "'" + correctString(row["latcard"]) + "',"
            sql = sql + "'" + correctString(row["latdeg"]) + "',"
            sql = sql + "'" + correctString(row["latmin"]) + "',"
            sql = sql + "'" + correctString(row["longcard"]) + "',"
            sql = sql + "'" + correctString(row["longdeg"]) + "',"
            sql = sql + "'" + correctString(row["longmin"]) + "',"
            sql = sql + "'" + correctString(row["elevation"]) + "',"
            sql = sql + "'" + correctString(row["prodsys"]) + "',"
            sql = sql + "'" + correctString(row["enumname"]) + "',"
            sql = sql + "'" + correctString(row["supname"]) + "',"
            sql = sql + "'3" + correctString(row["language"]) + "',"
            sql = sql + "'" + correctString(row["rankingnotes"]) + "')"
            try:
                myCur.execute(sql)  #Send the insert to MySQL                
                liteCur.execute('UPDATE ' + table + ' SET uploaded = 1 WHERE rowId = ' + str(rowID)) 
            except MySQLdb.Error,  e:
                #If there is an error then write the information to the log file
                # csproID is the row in CSPro containing the problem for each CaseID
                writeLog(cntMy, cntLite,  logFile, table, rowID,correctString(row["HH_ID"]),row["csproID"] ,e.args[0],e.args[1], sql )
         cntMy.commit() #Commits the inserts in MySQL
         cntLite.commit() #Commits updates in SQLite
    

# The following code is standard for all CSPro import scripts.

# Tool functions
# Write the log informato into a file

# This process tries to find a predefined error message using the constraint name in the table dict_errormsgs.
# The process assumes that the target database has the dictionary tables.
def getErrorMessage(cntMy, cntLite, rowId, record, errorDesc):
    #Finds the word CONSTRAINT in the error message. If idx < 0 then The error is not a reference error thus we return the error
    idx = errorDesc.find("CONSTRAINT")
    if idx >= 0:
        idx2 = errorDesc.find("FOREIGN KEY") #Find the word FOREIGN KEY
        cntr = errorDesc[idx+10+1:idx2-1] #Extracts the constraint name
        cntr = cntr.replace("`", "") #Remove unwanted characters
        cntr = cntr.strip() #Remove all spaces from start and end
        
        #print cntr   #Left here just in case of debuging
        
        myCur = cntMy.cursor() #Cursor to the MySQL database
        sql = "SELECT error_msg,error_notes,clm_cod FROM dict_relinfo WHERE cnt_name = '" + cntr + "'"
        try:
            myCur.execute(sql) #Select the descriptions
            rows = myCur.fetchall() #Retrieve the descriptions. Only one must be laoded
            for row in rows:
                errorDesc = row[0]  + '\t' + row[1]  # Return the first message
                
                liteCur = cntLite.cursor() #Cursor to the SQLite database
                sql = "SELECT " + row[2] + " FROM " + record + " WHERE rowId = " + str(rowId)
                try:
                    liteCur.execute(sql) #Select the value in the SQLite database. This will work as long as column name is the same in both MySQL and SQLite
                    liteRows = liteCur.fetchall()  #Retrive the value
                    for liteRow in liteRows:
                        errorDesc = errorDesc + " - Value not found = " + str(liteRow[0])
                except Exception as litee:
                    errorDesc = errorDesc + "";
                return errorDesc
            return errorDesc + '\t \t'
        except MySQLdb.Error,  e:
            return errorDesc + '\t \t' # If there is an error then return the description
    else:
        return errorDesc + '\t \t'
    

def writeLog(cntMy, cntLite, logFile,  record, rowId, mainID, csProID,  errorNo,  errorDesc,  sql):
    log = open(logFile, "a")
    errorMSG = getErrorMessage(cntMy, cntLite, rowId, record, errorDesc)
    cadena = record + '\t' + str(rowId) + '\t' + mainID + '\t' + str(csProID) + '\t'+ str(errorNo) + '\t' + errorMSG + '\t' + sql 
    log.write(cadena.encode('utf8')  + "\n")
    log.close()
    
def writeLog2(logFile,  record, rowId, mainID, csProID,  errorNo,  errorDesc, Notes,  sql):
    log = open(logFile, "a")
    cadena = record + '\t' + str(rowId) + '\t' + mainID + '\t' + str(csProID) + '\t' + str(errorNo) + '\t' + errorDesc + '\t' +  Notes + '\t' + sql 
    log.write(cadena.encode('utf8')  + "\n")
    log.close()

#Removes any ' from the data. Also it removes any unneccesary spaces
def correctString(source):
    if isinstance(source, basestring) == True:
        res = source.replace("'", "`")
        res = source.replace(";", ",")
        res = res.strip()
    else:
        res = str(source)
        
    res = getEmpty(res)
    
    return res

#Returns a -888 if the data is empty
def getEmpty(source):
    if isinstance(source, basestring) == True:
        if source.strip() == '' or source.strip() == 'None':
            return 'NULL'
        else:
            return source
    else:
        return str(source)

#Print the help of the script
def usage():
    helptext = '\nCSPro Import script from SQLite to Mysql\n\n'
    helptext = helptext + 'This script imports CSPro CSVs stored in an SQLite database into a MySQL database\n'
    helptext = helptext + 'Parameters:\n'
    helptext = helptext + '-h --host : MySQL host server. Default localhost \n'
    helptext = helptext + '-u --user : MySQL user\n'
    helptext = helptext + '-p --password : MySQL password\n'
    helptext = helptext + '-s --schema : MySQL schema\n'
    helptext = helptext + '-i --input : Input SQLite database file\n'
    helptext = helptext + '-t --table : Table in the SQLite database to be imported \n'
    helptext = helptext + '-o --output : Output log file. Default ./output.log\n'
    helptext = helptext + '-w : Overwrite the log file if exists, otherwise log data will be appended\n'
    helptext = helptext + '-l --help : Print this help \n\n'
    helptext = helptext + "This script was generated by META's CSProToPythonScript tool\n\n"
    helptext = helptext + "META (c) ILRI, 2012"
    print helptext

# Main function
def main():
    #Obtain the comamnd line arguments
    try:
        opts, args = getopt.getopt(sys.argv[1:], "lh:u:p:s:i:t:o:w", ["help", "host=", "user=", "password=", "schema=", "input=", "table=", "output="])
    except getopt.GetoptError, err:
        print str(err) #If there is an error then print it
        usage() #Print the help
        sys.exit(1) #Exits with error
    
    #Input variables
    host = 'localhost' #The MySQL Host
    user = 'someUser' #The MySQL User name
    schema = 'someSchema' #The MySQL Schema name
    password = 'secret!!!' #The MySQL User password
    inputFile = './input.sqlite' #The SQLite input database
    table = 'aTable' #The table to process
    outputLog = './output.csv' #The file to log the error
    overWrite = False #If the process overwrites the log file
    
    if len(opts) == 0:
        usage() #Print the help
        sys.exit(1) #Exits with error
    
    #This for statement gets each command line argument and fill avobe variables
    for o, a in opts:
        if o in ("-w"):
            overWrite = True
        elif o in ("-l", "--help"):
            usage()
            sys.exit()
        elif o in ("-h", "--host"):
            host = a
        elif o in ("-u", "--user"):
            user = a
        elif o in ("-s", "--schema"):
            schema = a
        elif o in ("-p", "--password"):
            password = a
        elif o in ("-i", "--input"):
            inputFile = a
        elif o in ("-t", "--table"):
            table = a
        elif o in ("-o", "--output"):
            outputLog = a
        else:
            assert False, "unhandled option"
    
    #Print some of the variables
    print 'Host     :', host
    print 'User     :', user
    print 'Schema   :', schema
    print 'Input    :', inputFile
    print 'Table    :', table
    print 'Outoput  :', outputLog
    
    try:
        with open(outputLog) as f: pass #Try to open the log file
        if overWrite == True: #If overwrite log
            os.remove(outputLog) #Delete the previous file and then write the heading
            writeLog2(outputLog,  'RecordInCSPro', 'RowInSQLite', 'CaseID', 'RowInCSPro', 'MySQLErrorNumber',  'MySQLError',  'Notes',  'SQLExecuted')
    except IOError as e: 
        #If the log file cannot be open the its assumed it does not exits. Then write the heading
        writeLog2(outputLog,  'RecordInCSPro', 'RowInSQLite', 'CaseID', 'RowInCSPro', 'MySQLErrorNumber',  'MySQLError',  'Notes',  'SQLExecuted')
    
    #Try to connect to SQLite and MySQL
    try:
      with open(inputFile) as f: pass #Checks if the SQLite database exists
      liteCon = lite.connect(inputFile) #Connect to the SQLite database
      
      try:
          myCon = MySQLdb.connect(host, user, password, schema) #Connect to MySQL          
          processTable(liteCon, myCon, table, outputLog) #Process the table
          
      #If the script cannot connect to MySQL
      except MySQLdb.Error,  e:
          if liteCon:
              liteCon.close(); #Close the connecto to SQLite
          print "Error %d: %s" % (e.args[0],e.args[1]) #Print the error
          sys.exit(1) #Exits with error
      
    except IOError as e:
      print 'Error connecting to sqlite input file' #Print the error
      sys.exit(1) #Exits with error
    
#Load the main function at start
if __name__ == "__main__":
    main()
